Question : ğ’ğªğ®ğšğ ğ’ğğ¥ğŸğ¢ğ â€“ ğ…ğ¢ğ§ğ ğ­ğ¡ğ ğŒğ¢ğğğ¥ğ ğ…ğ¢ğ¥ğ­ğğ« ğŸ’–

ğŸ“¸ ğ“ğ¡ğ ğ’ğ­ğ¨ğ«ğ² : ğ“ğ°ğ¨ ğŸğ«ğ¢ğğ§ğ ğ¬ğªğ®ğšğğ¬ ğŸ“±ğŸ’¬ â€” let's call them:
SquadSnap ğŸ˜ â†’ nums1
SquadTok ğŸ¤³ â†’ nums2
Theyâ€™ve rated their fav selfie filters on a scale from -106 to 106 ğŸ”¥ (yes, some people weirdly hate filters that much ğŸ˜…).
Now both squads wanna combine their filter ratings and find the middle-most rating â€” the one that represents the vibe of the entire group ğŸ§˜â€â™€ï¸âœ¨.That's what we call the median filter ğŸ“·.

ğŸ¯ ğ˜ğ¨ğ®ğ« ğ†ğ¨ğšğ¥ : Write a function to find the middle filter rating when both squads combine their sorted ratings â€” but do it super fast âš¡ (not by just merging and sorting).

ğŸ§© ğˆğ§ğ©ğ®ğ­ : ğ˜ğ¨ğ® ğ ğğ­ ğ­ğ°ğ¨ ğ¬ğ¨ğ«ğ­ğğ ğ¥ğ¢ğ¬ğ­ğ¬ -
squad_snap = [1, 3]     # Sorted selfie filter ratings from Snap Squad
squad_tok = [2]         # Sorted selfie filter ratings from Tok Squad 

ğŸ§  ğ–ğ¡ğšğ­ ğ²ğ¨ğ® ğ¡ğšğ¯ğ ğ­ğ¨ ğğ¨? â†’ Combine both the lists into 1 vibe list ğŸ’« â†’ [1, 2, 3] :- Find the middle rating by following the below conditions
- If list is odd length, return the center one
- If it's even, return the average of the two middle ones

âœ… ğ„ğ±ğšğ¦ğ©ğ¥ğğ¬ :
ğŸ“· Example 1 : squad_snap = [1, 3] and squad_tok = [2]
Combined : [1, 2, 3] â†’ Middle filter = 2.0 = Median 
ğŸ“· Example 2 : squad_snap = [1, 2] and squad_tok = [3, 4]
Combined : [1, 2, 3, 4] â†’ Middle filters = 2 and 3 â†’ Median = (2 + 3)/2 = 2.5

ğŸ§ƒ ğ‘ğ®ğ¥ğğ¬ ğ¨ğ« ğ‚ğ¨ğ§ğ¬ğ­ğ«ğšğ¢ğ§ğ­ğ¬ :
â†’ You can have 0 to 1000 filters in each squad.
â†’ At least one squad should have filters (no dry parties).
â†’ Filter ratings can go from -106 (yuck) to 106 (slay).
â†’ No slow solutions â€“ youâ€™re a fast texter, be a fast coder too ğŸï¸
â†’ Target time: O(log(m + n))

ğŸ’¬ ğ“ğ‹;ğƒğ‘ [ Too Long,Don't Read ] a.k.a [ small hint ] : Think of it as choosing the most balanced filter everyone in both squads can vibe withğŸ§˜â€â™‚ï¸ğŸ“·

Solutions or Different Methods to solve this problem :-
#Approach 1 : ğğ«ğ®ğ­ğ ğ…ğ¨ğ«ğœğ ğ€ğ©ğ©ğ«ğ¨ğšğœğ¡ [ Time Complexity : O((m + n) * log(m + n)) ; Space Complexity : O(m + n) ]
ğğ²ğ­ğ¡ğ¨ğ§ ğ‹ğšğ§ğ ğ®ğšğ ğ :- 
class Solution:
    def findMedianSortedArrays(self, nums1, nums2):
        merged = nums1 + nums2 # Merge the two arrays
        merged.sort() #Sorting the merged array 
        n = len(merged) # Finding the total number of elements
        if n % 2 == 1: #Check if the total number of the elements is odd
            return float(merged[n // 2]) #Odd Total number of elements which means there is only 1 single element in the middle therefore returning the middle element converting it to the float
        else:  #for even numbers there are two middle numbers : left middle and right middle
            mid1 = merged[n // 2] #right-middle
            mid2 = merged[n // 2 - 1] #left-middle
            return (mid1 + mid2) / 2
ğŸ¯ Example Walkthrough ( Dry running the Brute Force Approach ) :
For nums1 = [1, 2], nums2 = [3, 4]:
merged = [1, 2, 3, 4]
n = 4 â†’ even
Median = (2 + 3) / 2 = 2.5

Now we are diving into the ğ“ğ°ğ¨ ğğ¨ğ¢ğ§ğ­ğğ« ğŒğğ«ğ ğ ğ€ğ©ğ©ğ«ğ¨ğšğœğ¡ , which is more efficient than brute force because:
âœ… It avoids full sorting
âœ… It tracks only up to the median
âœ… It works in O(m + n) time
#Approach 2 : ğ“ğ°ğ¨ ğğ¨ğ¢ğ§ğ­ğğ« ğŒğğ«ğ ğ ğ–ğ¢ğ­ğ¡ğ¨ğ®ğ­ ğ’ğ¨ğ«ğ­ğ¢ğ§ğ  [ Time Complexity : O(m+n) ; Space Complexity : O(1) ]
ğğ²ğ­ğ¡ğ¨ğ§ ğ‹ğšğ§ğ ğ®ğšğ ğ :-
class Solution:
    def findMedianSortedArrays(self, nums1, nums2): #self	refers to the current instance of the class (W/o self errors will definitely come )
        m, n = len(nums1), len(nums2)
        total = m + n
        mid = total // 2 #always taking the floor function

        i = j = 0  # Pointers for nums1 and nums2
        prev = curr = 0  # To store the last two elements seen

        for _ in range(mid + 1): #_ really donâ€™t care which round weâ€™re on (_), just get me the middle!  
# We use mid + 1 because we need to walk up to and include the middle.
            prev = curr

            if i < m and (j >= n or nums1[i] < nums2[j]):  # Choose smaller current value from both arrays
                curr = nums1[i]
                i += 1
            else:
                curr = nums2[j]
                j += 1

        if total % 2 == 0:  # If total length is even â†’ median = average of two middle values
            return (prev + curr) / 2
        else:  # If odd â†’ median = middle value
            return curr * 1.0

#Approach 3 : Binary Search Partitioning [ Time Complexity : O(log(min(m, n))) ; Space  Complexity : O(1) ] 
ğğ²ğ­ğ¡ğ¨ğ§ ğ‹ğšğ§ğ ğ®ğšğ ğ :-
class Solution:
    def findMedianSortedArrays(self, nums1, nums2):
            nums1, nums2 = nums2, nums1 # Ensure nums1 is the smaller array
        if len(nums1) > len(nums2): #Swap nums1 and mums2 with each other
        m, n = len(nums1), len(nums2) 
        low, high = 0, m # low is the start of binary search range (min cut position in nums1) and high is the end of the binary search range ( max cut position in nums1 )

        while low <= high: #Now we are searching from low to high(Binary Search)
            i = (low + high) // 2 #Partition point (cut) in nums1	: "How many elements should go into the left half from nums1?"
            j = (m + n + 1) // 2 - i #Partition point (cut) in nums2 : "How many elements should go into the left half from nums2?"

            maxLeft1 = float('-inf') if i == 0 else nums1[i - 1]
            minRight1 = float('inf') if i == m else nums1[i]

            maxLeft2 = float('-inf') if j == 0 else nums2[j - 1]
            minRight2 = float('inf') if j == n else nums2[j] #Take maximum of left side and minimum of right side of both the arrays named nums1 and nums2

            if maxLeft1 <= minRight2 and maxLeft2 <= minRight1: #loop for returning the median element for the median of maxLeft and minRight
                # Found the correct partition
                if (m + n) % 2 == 0:
                    return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2
                else:
                    return max(maxLeft1, maxLeft2)  
            elif maxLeft1 > minRight2:
                high = i - 1
            else:
                low = i + 1

#Approach 4 : Recursive K-th Element Finder (Divide & Conquer) [ Time Complexity : O(log(m + n)) ; Space Complexity : O(log(m + n)) (due to recursion) ] 
ğğ²ğ­ğ¡ğ¨ğ§ ğ‹ğšğ§ğ ğ®ğšğ ğ :-
class Solution:
    def findMedianSortedArrays(self, nums1, nums2):
        def getKthElement(arr1, arr2, k):
            index1 = index2 = 0
            while True:
                if index1 == len(arr1):
                    return arr2[index2 + k - 1]
                if index2 == len(arr2):
                    return arr1[index1 + k - 1]
                if k == 1:
                    return min(arr1[index1], arr2[index2])

                newIndex1 = min(index1 + k // 2 - 1, len(arr1) - 1)
                newIndex2 = min(index2 + k // 2 - 1, len(arr2) - 1)
                pivot1, pivot2 = arr1[newIndex1], arr2[newIndex2]

                if pivot1 <= pivot2:
                    k -= (newIndex1 - index1 + 1)
                    index1 = newIndex1 + 1
                else:
                    k -= (newIndex2 - index2 + 1)
                    index2 = newIndex2 + 1

        totalLength = len(nums1) + len(nums2)
        if totalLength % 2 == 1:
            return getKthElement(nums1, nums2, totalLength // 2 + 1)
        else:
            return (getKthElement(nums1, nums2, totalLength // 2) +
                    getKthElement(nums1, nums2, totalLength // 2 + 1)) / 2
